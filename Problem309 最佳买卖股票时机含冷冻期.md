# Problem309 最佳买卖股票时机含冷冻期

## 题目描述

给定一个整数数组，其中第i个元素表示第i天的股票价格。

设计一个算法计算出最大利润，在满足以下约束条件的前提下完成尽可能多的交易：

- 你不能同时参加多笔交易
- 卖出股票后，无法在第二天买入股票（即冷冻期为1天）

## 思路 动态规划

先给大家看一个错误代码，注释写的很详细，挺好理解的。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        #动态规划，使用二维数组，第一维度表示天数，第二维度表示状态,dp[i][j]表示在第i天，j状态下的利润
        #状态分为以下三种：
        #   1.状态0表示买入状态，当天执行买入之后直到卖出之前都是买入状态
        #   2.状态1表示卖出状态，除了冷冻期和买入状态之外就是卖出状态，卖出当天开始就算卖出状态
        #   3.状态2表示冷冻期状态，卖出之后第一天就是冷冻状态
        n = len(prices)
        if n < 2:
            return 0
        #初始化dp
        dp = [[0 for _ in range(3)] for _ in range(n)]
        #第一天就进入卖出或者冷冻期状态显然是不可能的，直接将他们的利润赋0就可以了
        dp[0][0] = -prices[0]
        dp[0][1] = 0
        dp[0][2] = 0
        for i in range(1, n):
            #第i天是买入状态，它可能由以下三种情况转换而来：
            #   1.昨天是买入状态，这表示持仓没动
            #   2.昨天是卖出状态，然后今天执行买入操作
            #   3.昨天是冷冻状态，然后今天执行买入操作
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i], dp[i-1][2]-prices[i])
            #第i天是卖出状态，它可能由以下三种情况转换而来：
            #   1.昨天是买入状态，今天卖出
            #   2.昨天是卖出状态，然后今天没有执行操作
            #   3.昨天是冷冻状态，然后今天没有执行操作
            dp[i][1] = max(dp[i-1][0]+prices[i], dp[i-1][1], dp[i-1][2])
            #第i天是冷冻状态，只能是由昨天的卖出状态转换而来
            dp[i][2] = dp[i-1][1]
        return max(dp[i-1][0], dp[i-1][1], dp[i-1][2])
```

这个思路错误的原因是，主要原因是卖出当天的第二天是不能执行买入操作的，我上面的状态转移方程的第一个是错的。怎么处理呢？很简单，加一个卖出当天状态就行，直接看代码：

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        #动态规划，使用二维数组，第一维度表示天数，第二维度表示状态,dp[i][j]表示在第i天，j状态下的利润
        #状态分为以下四种：
        #   1.状态0表示买入状态，当天执行买入之后直到卖出之前都是买入状态
        #接下来的状态都属于卖出状态，也就是从卖出当天到买入状态，但是具体还是分为三个状态
        #   2.状态1表示卖出剩余状态，它表示卖出状态下除了卖出当天状态和冷冻状态之外，剩下的状态
        #   3.状态2表示冷冻期状态，卖出之后第一天就是冷冻状态
        #   4.状态3比较特殊，它仅仅表示卖出当天的状态，我们就把它定义为卖出当天状态
        n = len(prices)
        if n < 2:
            return 0
        #初始化dp
        dp = [[0 for _ in range(4)] for _ in range(n)]
        #第一天就进入卖出或者冷冻期状态或者卖出剩余状态显然是不可能的，直接将他们的利润赋0就可以了
        dp[0][0] = -prices[0]
        dp[0][1] = 0
        dp[0][2] = 0
        dp[0][3] = 0
        for i in range(1, n):
            #第i天是买入状态，它可能由以下三种情况转换而来：
            #   1.昨天是买入状态，这表示持仓没动
            #   2.昨天是卖出剩余状态，然后今天执行买入操作
            #   3.昨天是冷冻状态，然后今天执行买入操作
            #注意买入状态不能由卖出当天状态转换而来
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i], dp[i-1][2]-prices[i])
            #第i天是卖出剩余状态
            #   1.昨天也是卖出剩余状态
            #   2.昨天是冷冻状态
            dp[i][1] = max(dp[i-1][1], dp[i-1][2])
            #第i天是冷冻状态，只能是由昨天的卖出当天状态转换而来
            dp[i][2] = dp[i-1][3]
            #第i天是卖出当天状态，它只能由昨天的买入状态转换而来
            dp[i][3] = dp[i-1][0] + prices[i]
        return max(dp[n-1][0], dp[n-1][1], dp[n-1][2], dp[n-1][3])
```

**复杂度分析：**

- 时间复杂度：O(n)
- 空间复杂度：O(4n)