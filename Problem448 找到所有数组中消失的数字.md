# Problem448 找到所有数组中消失的数字

## 题目描述

给定一个范围在1<=a[i]<=n(n为数组大小)的整型数组，数组中的元素一些出现了两次，另一些只出现了一次。

找出所有在[1,n]范围之间没有出现在数组中的数字。

要求不能使用额外的空间，并且时间复杂度为O(n).

## 思路

这个题的题目的题目描述有没有感觉有些类似，大家可以看一下287题寻找重复数的题目。

![image-20201228110056821](C:\Users\初泽良\AppData\Roaming\Typora\typora-user-images\image-20201228110056821.png)

还记得这个题的思路是什么吗？构造环形链表，然后通过找到环的入口来找到相应的元素，关键是怎么构造环形链表？利用了**数组的特殊性质：数字都在1到n之间**。

这个题和287题有着异曲同工之妙，因为它的限制条件也差不多，所以我们就很自然地想到了**将数组的元素作为数组下标来进行寻找**，这背后的道理就是**如果一个1-n之间的某个数字不在数组中，那么以这个元素为下标的元素肯定是访问不到的**，所以基于此我们可以通过遍历数组元素，然后将每个数组元素作为下标来访问它所对应的元素，并标记这个元素。标记的目的是为了看最后有哪个元素没有被标记，那么它对应的下标的数字就是不在数组中的。

**下面的一个关键问题是如何标记？**

想要标记一个元素很简单，你可以把它标记为不在1-n中的任意一个数，比如说我最开始标记的时候选择了0，访问到一个元素就把它标记为0，大家也可以使用我的方法来试一下，看看为什么不行。

如果将一个元素标记为0的话，你后面再访问这个元素的时候就没有办法通过这个元素找到它对应的下标，因为你已经把它修改为0了，所以这样是不行的，那么思考一下**改成什么能够达到标记的目的，同时保留数字的大小**。很显然，相反数！变成相反数字之后数字的符号发生了变化，但是绝对值的大小并没有发生改变，所以我们需要在标记的时候将数字改为它的相反数，当下次访问到的时候就将这个数字变回来再重新找它所对应的下标。最后遍历下数组，哪个数字不是负的，就说明这个数字的下标对应的数字没有在数组中出现过。

废话不多说，直接上代码。

```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            nums[abs(num)-1] = -abs(nums[abs(num)-1])
        print(nums)
        for i in range(len(nums)):
            if nums[i] > 0:
                res.append(i+1)
        return res
```

复杂度满足了题目的要求。