# Problem337 打家劫舍3

## 题目描述

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

示例 1:

输入: [3,2,3,null,3,null,1]

     3
    / \
    2  3
     \  \ 
      3  1
输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.

## 思路

这个题是一个使用对树结构进行动态规划的问题，其实我们回想一下动态规划的问题中，一般是对数组进行遍历，然后根据前一个元素和后一个元素的状态关系来进行动态规划的求解。如果推广到树上我们应该怎么理解呢？其实就是将对数组的遍历变成对树的遍历，树的遍历的几种方式中最常用的就是后序遍历。

这个题为什么要用后序遍历呢？因为我们需要先知道叶子节点的信息然后才能决定当前节点的信息是什么，这种顺序就是后序遍历。

### 1.定义状态

dp\[node]\[j]：这里node表示一个节点，以node为根节点的树，并且规定了node是否能够获得的最大值。node的遍历是通过后序遍历递归的方式是来实现的。

​	j=0表示不偷

​	j=1表示偷

### 2.状态转移方程

根据当前节点偷或者不偷，就决定了需要从哪些子节点的状态转移过来。

- 如果当前节点不偷，那么左右子节点偷或者不偷都行，选最大的
- 如果当前节点偷，左右子节点就均不能偷

### 3.初始化

一个节点都没有，空节点，返回0，对应后序遍历递归的终止条件。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def rob(self, root: TreeNode) -> int:
        res = self.dfs(root)
        return max(res[0], res[1])
    
    def dfs(self, node):
        if node is None:
            return [0,0]
        
        left = self.dfs(node.left)
        right = self.dfs(node.right)

        dp = [0, 0]
        #dp[0]表示以当前节点不偷状态下子树能够偷取的最大值,注意当前节点不偷的话，它的子树可以偷也可以不偷
        dp[0] = max(left[0], left[1]) + max(right[0], right[1])
        #dp[1]表示当前节点偷状态下子树能够偷取的最大值
        dp[1] = node.val + left[0] + right[0]
        return dp
```

