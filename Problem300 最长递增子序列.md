# Problem300 最长递增子序列

## 题目描述

给你一个整数数组，找到其中最长严格递增子序列的长度。

- 要求设计时间复杂度为O(n^2)的解决方案。
- 能将算法的时间复杂度降低到O(nlogn)

**这个题不会做**

## 思路1 动态规划 

这个题是一道动态规划的经典题，在美团校招和华为算法面试的时候都曾出现过。

**解题思路：**

- 状态定义
  - 我们在动态规划定义状态的时候，一般考虑题目问什么，就把什么定义为状态。题目中问最长上升子序列的长度，其实可以把dp[i]定义为从nums[0]到nums[i]的所有元素的最长上升子序列的长度，但是我们思考一下为什么定义这样的状态不好，主要考虑的是，**这样的状态方便你写动态转移方程吗？**我们可以想一下，对于dp[i]和dp[j]，假设i<j，那么当我们要求dp[j]的值的时候，**我们能根据dp[i]的值推导出dp[j]的值吗？**因为要考虑上升子序列的问题，所以要比较nums[j]和nums[i]的大小，那么如果**nums[j]>nums[i]，这个时候dp[j]=dp[i]+1吗？**不行，因为dp[i]代表的是从nums[0]到nums[i]的所有元素的最长上升子序列的长度，这个上升子序列不一定是以nums[i]结尾的，如果不以nums[i]结尾，就无法断定nums[j]是否比dp[i]代表的那个最长上升子序列的最大值大，所以你就**写不出状态转移方程来**。
  - 所以，dp[i]的值为考虑前i个元素，以**第i个数字结尾**的最长上升子序列的长度，**注意nums[i]必须被选取**。
- 考虑状态转移方程
  - 明白了上面状态定义之后，再思考状态转移方程就比较简单了。
  - 设0<= j < i，我们在考虑每轮计算新的dp[i]的时候，遍历[0,i)区间
    - 当nums[i]>nums[j]的时候，nums[i]可以接在nums[j]之后，那么最长上升子序列的长度就是dp[j]+1
    - 当nums[i]<=nums[j]的时候，nums[i]无法接在nums[j]之后，这个时候就不能构成上升子序列，跳过
  - 所以状态转移方程为 dp[i] = max(dp[i], dp[j] + 1) for j in [0,j）
- 初始状态：将dp[i]的所有元素置为1，这样的涵义是每个元素都至少可以单独成为一个子序列，此时长度为1
- 最后求得dp列表的最大值就是答案

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
        dp = [1 for _ in range(n)]
        for i in range(len(nums)):
            for j in range(i):
                # 如果要求非严格递增，将此行 '<' 改为 '<=' 即可。
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

**复杂度分析：**

- 时间复杂度：O(N^2)
- 空间复杂度：O(N)

## 思路2 贪心＋二分查找——摘自官方题解方法二

官方题解已经写的足够好了，大家可以参考官方题解。