# Problem287 寻找重复数

## 题目描述

给定一个包含n+1个整数的数组nums，其数字都在1-n之间（包括1和n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

## 思路1 二分查找

这个题其实很自然的应该想到遍历，然后对每个元素进行二分查找，可是一个问题的关键就是这个数组是无序的，所以这样的话很显然是走不通的。

这个题的一个关键前提是说：**给定一个包含n+1个整数的数组nums，其数字都在1-n之间（包括1和n）。**

那么其实我们可以通过将1-n这个区间来进行划分，不断地二分来找到1-n中重复出现的数字。那么通过什么依据来选择左半边区间还是右半边区间呢？肯定是通过重复的数字在left-mid还是在mid-right中，那么接下来的问题就是思考：**怎么判断重复的数字在left-mid中还是在mid-right中？**

我们使用一个例子来说明：

[2,4,5,2,3,1,6,7]，这个数组中总共8个数，也就是n=7,所以每个数字都在1-7之间。

1-7的中位数是4，然后我们遍历整个数组，统计小于等于4的整数的个数。**如果整个数组中小于等于4的数字的个数大于4的时候，重复的数一定是存在区间[1,4]中，如果整个数组中小于等于4的数字的个数小于等于4的时候，重复的数一定是存在区间[4,7]中。**

所以基于此，我们就可以写出二分法的代码了。

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        size = len(nums)
        left = 1
        right = size - 1

        while left < right:
            mid = left + (right - left) // 2

            count = 0
            for num in nums:
                if num <= mid:
                    count += 1
            # 根据抽屉原理，小于等于 4 的数的个数如果大于 4 个，
            # 此时重复元素一定出现在 [1, 4] 区间里

            if count > mid:
                # 重复的元素一定出现在 [left, mid] 区间里
                right = mid
            else:
                #否则如果小于等于4的数字的个数小于等于mid的话，重复元素一定位[mid + 1, right]区间内
                left = mid + 1
        return left
```

**复杂度分析：**

- 时间复杂度：O(nlogn)
- 空间复杂度：O(1)

## 思路2 快慢指针

这个方法比上面的方法更难想，主要想法是通过这个数组构造一个链表，然后根据快慢指针来找到重复元素。

第一步的关键是**如何通过这样一个数组来构造一个链表——建立一个映射**。

**数组下标——>数组元素——>将数组元素作为数组下标——>映射为数组元素**

这样其实就构成了一个链表，而且由于重复数字的存在，会构成一个环形链表。

拿[1,3,4,2,2]为例：

0->1->3->2->4->2->4->2.......

这样就构成了一个循环链表，然后我们观察这个环形链表可以看出这个环形的入口处就是重复元素，所以接下来的问题就是**如何找到环形链表的入口元素**。

在环形链表的题目中，一般都是用快慢指针来判断是否存在环形链表，然后也可以通过快慢指针来找到环形链表的入口元素。

具体方法是：

- 使用slow  fast指针来遍历链表，这两个指针会在环中相遇。假设起点到环的入口的长度为 length, 环的周长为circle, slow指针走了n步，那么fast指针走了2n步，而且很显然fast指针多走的这n步都是在环里循环了，也就是可以得到n%c == 0。
- 设立第三个指针finder来找环的入口，它从起点开始和slow同步前进（这个时候slow在和fast的相遇处），然后当finder和slow相遇的时候，相遇点就是环的入口处，也就是重复元素。
  - 解释一下为什么finder和slow的相遇处就是入口元素。当slow和fast相遇的时候，slow在**环中走了n-length的距离**，然后这个时候我们让slow又走了length的距离（也就是finder走到入口处的距离），这个时候slow**在环中就走了n的距离**，而n%c==0，所以slow在环中走的距离就是环的周长的整数倍了，也就是走到了环的入口处。
  - 我们之所以需要搞这个一个finder指针是因为我们不知道length，需要通过finder和slow同步走达到让slow走length的距离的目的。

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        fast, slow = 0, 0
        while True:
            fast = nums[nums[fast]]
            slow = nums[slow]
            if fast == slow:
                break
        finder = 0
        while True:
            finder = nums[finder]
            slow = nums[slow]
            if slow == finder:
                break
        return slow
```

**复杂度分析：**

- 时间复杂度：O(n)
- 空间复杂度：O(1)